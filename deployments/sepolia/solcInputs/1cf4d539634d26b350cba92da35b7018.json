{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "contracts/core/LaunchManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./TokenFactory.sol\";\r\nimport \"../extensions/LiquidityManager.sol\";\r\nimport \"../interfaces/IToken.sol\";\r\n\r\ncontract LaunchManager {\r\n    TokenFactory public tokenFactory;\r\n    address payable public liquidityManagerAddress;\r\n    \r\n    uint256 public launchFee;\r\n    address public feeCollector;\r\n\r\n    mapping(address => bytes32) public launchCommits;\r\n    \r\n    struct LaunchParams {\r\n        string name;\r\n        string symbol;\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        address[4] initialHolders;\r\n        uint256[4] initialAmounts;\r\n        bool enableAntiBot;\r\n        uint256 maxTxAmount;\r\n        uint256 maxWalletAmount;\r\n        address pairWith;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 liquidityAmount;\r\n        uint256 pairAmount;\r\n        uint256 lockDuration;\r\n    }\r\n    \r\n    event LaunchCompleted(address indexed tokenAddress, uint256 indexed liquidityTokenId);\r\n    \r\n    constructor(\r\n        address _tokenFactory,\r\n        address payable _liquidityManager,\r\n        address _feeCollector,\r\n        uint256 _launchFee\r\n    ) {\r\n        tokenFactory = TokenFactory(_tokenFactory);\r\n        liquidityManagerAddress = _liquidityManager;\r\n        feeCollector = _feeCollector;\r\n        launchFee = _launchFee;\r\n    }\r\n\r\n    function commitLaunch(bytes32 hash) external {\r\n        launchCommits[msg.sender] = hash;\r\n    }\r\n    \r\n    function instantLaunch(LaunchParams calldata params, bytes32 salt) external payable {\r\n        require(msg.value >= launchFee + params.pairAmount, \"Insufficient ETH\");\r\n\r\n        require(\r\n            launchCommits[msg.sender] == keccak256(abi.encode(params, salt)),\r\n            \"Invalid commit\"\r\n        );\r\n        delete launchCommits[msg.sender];\r\n    \r\n        // Deduct fees first\r\n        uint256 operationCost = launchFee + params.pairAmount;\r\n        (bool sent, ) = feeCollector.call{value: launchFee}(\"\");\r\n        require(sent, \"Fee transfer failed\");\r\n        \r\n        // Create token with remaining ETH\r\n        address tokenAddress = _createToken(params);\r\n        \r\n        // Create liquidity with designated amount\r\n        uint256 liquidityTokenId = _createLiquidity(tokenAddress, params);\r\n        \r\n        // Refund any excess (now safe after all operations)\r\n        if (address(this).balance > 0) {\r\n            (bool refunded, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n            require(refunded, \"Refund failed\");\r\n        }\r\n\r\n        emit LaunchCompleted(tokenAddress, liquidityTokenId);\r\n    }\r\n\r\n    function _createToken(LaunchParams calldata params) private returns (address) {\r\n        return tokenFactory.createToken{value: msg.value}(\r\n            params.name,\r\n            params.symbol,\r\n            params.decimals,\r\n            params.totalSupply,\r\n            params.initialHolders,\r\n            params.initialAmounts,\r\n            params.enableAntiBot,\r\n            params.maxTxAmount,\r\n            params.maxWalletAmount\r\n        );\r\n    }\r\n\r\n    function _createLiquidity(address tokenAddress, LaunchParams calldata params) private returns (uint256) {\r\n        LiquidityManager liquidityManager = LiquidityManager(liquidityManagerAddress);\r\n        return liquidityManager.createLiquidityPool{value: params.pairAmount}(\r\n            tokenAddress,\r\n            params.pairWith,\r\n            params.fee,\r\n            params.tickLower,\r\n            params.tickUpper,\r\n            params.liquidityAmount,\r\n            params.pairAmount,\r\n            params.lockDuration\r\n        );\r\n    }\r\n}"
    },
    "contracts/core/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./TokenTemplate.sol\";\r\nimport \"../interfaces/IToken.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract TokenFactory is Ownable {\r\n    address public feeCollector;\r\n    uint256 public creationFee;\r\n   \r\n    mapping(address => address[]) public creatorTokens;\r\n    address[] public allTokens;\r\n   \r\n    event TokenCreated(address indexed creator, address tokenAddress);\r\n    event FeeCollectorUpdated(address indexed oldCollector, address indexed newCollector);\r\n    event CreationFeeUpdated(uint256 oldFee, uint256 newFee);\r\n   \r\n    constructor(address _feeCollector, uint256 _creationFee) Ownable(msg.sender) {\r\n        // Use OZ Ownable's constructor implicitly\r\n        feeCollector = _feeCollector;\r\n        creationFee = _creationFee;\r\n    }\r\n   \r\n    function createToken(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 totalSupply,\r\n        address[4] memory initialHolders,\r\n        uint256[4] memory initialAmounts,\r\n        bool enableAntiBot,\r\n        uint256 maxTxAmount,\r\n        uint256 maxWalletAmount\r\n    ) external payable returns (address) {\r\n        require(msg.value >= creationFee, \"Insufficient fee\");\r\n        require(initialHolders.length == initialAmounts.length, \"Holders and amounts mismatch\");\r\n       \r\n        // Create new token contract\r\n        TokenTemplate token = new TokenTemplate(\r\n            name,\r\n            symbol,\r\n            decimals,\r\n            totalSupply,\r\n            msg.sender,\r\n            initialHolders,\r\n            initialAmounts,\r\n            enableAntiBot,\r\n            maxTxAmount,\r\n            maxWalletAmount\r\n        );\r\n       \r\n        // Record token creation\r\n        creatorTokens[msg.sender].push(address(token));\r\n        allTokens.push(address(token));\r\n       \r\n        // Pay fee to collector\r\n        (bool sent, ) = payable(feeCollector).call{value: creationFee}(\"\");\r\n        require(sent, \"Fee transfer failed\");\r\n\r\n        // Refund excess fee\r\n        if (msg.value > creationFee) {\r\n            (bool refundSent, ) = payable(msg.sender).call{value: msg.value - creationFee}(\"\");\r\n            require(refundSent, \"Refund failed\");\r\n        }\r\n       \r\n        emit TokenCreated(msg.sender, address(token));\r\n        return address(token);\r\n    }\r\n   \r\n    function getCreatorTokens(address creator) external view returns (address[] memory) {\r\n        return creatorTokens[creator];\r\n    }\r\n   \r\n    function getCreatorTokenCount(address creator) external view returns (uint256) {\r\n        return creatorTokens[creator].length;\r\n    }\r\n   \r\n    function getTotalTokenCount() external view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n   \r\n    function updateFeeCollector(address _newCollector) external onlyOwner {\r\n        require(_newCollector != address(0), \"Invalid collector address\");\r\n        address oldCollector = feeCollector;\r\n        feeCollector = _newCollector;\r\n        emit FeeCollectorUpdated(oldCollector, _newCollector);\r\n    }\r\n   \r\n    function updateCreationFee(uint256 _newFee) external onlyOwner {\r\n        uint256 oldFee = creationFee;\r\n        creationFee = _newFee;\r\n        emit CreationFeeUpdated(oldFee, _newFee);\r\n    }\r\n}"
    },
    "contracts/core/TokenTemplate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../extensions/AntiBot.sol\";\r\nimport \"../utils/SecurityUtils.sol\";\r\n\r\ncontract TokenTemplate is ERC20, Ownable {\r\n    using AntiBot for AntiBot.AntiBotConfig;\r\n    using SecurityUtils for SecurityUtils.SecuritySettings;\r\n\r\n    bool public tradingEnabled;\r\n    uint256 public launchTime;\r\n    uint256 public launchBlock;\r\n    \r\n    // Flag to track initial distribution status\r\n    bool private _initialDistributionComplete;\r\n    \r\n    AntiBot.AntiBotConfig private _antiBotConfig;\r\n    SecurityUtils.SecuritySettings private _securitySettings;\r\n    \r\n    mapping(address => bool) public isExcludedFromLimits;\r\n\r\n    event TradingEnabled(uint256 timestamp);\r\n    event AntiBotConfigUpdated(bool enabled, uint256 maxTxAmount, uint256 maxWalletAmount);\r\n    event SecuritySettingsUpdated(bool paused);\r\n    event ContractStatusChanged(address indexed contractAddr, bool trusted, bool blocked);\r\n    event InitialDistributionComplete();\r\n    \r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 totalSupply,\r\n        address _initialOwner,\r\n        address[4] memory initialHolders,\r\n        uint256[4] memory initialAmounts,\r\n        bool enableAntiBot,\r\n        uint256 maxTxAmount,\r\n        uint256 maxWalletAmount\r\n    ) ERC20(name, symbol) Ownable(_initialOwner) {\r\n        require(initialHolders.length == initialAmounts.length, \"Arrays length mismatch\");\r\n        \r\n        _securitySettings.initialize();  // Initialize with minimal defaults\r\n        \r\n        // Mint tokens to the contract creator (TokenFactory)\r\n        _mint(msg.sender, totalSupply * (10 ** decimals));\r\n        \r\n        // Perform initial distributions without trading check\r\n        _initialDistributionComplete = false;\r\n        for (uint i = 0; i < initialHolders.length; i++) {\r\n            if (initialHolders[i] != address(0) && initialAmounts[i] > 0) {\r\n                _transfer(msg.sender, initialHolders[i], initialAmounts[i]);\r\n            }\r\n        }\r\n        _initialDistributionComplete = true;\r\n        emit InitialDistributionComplete();\r\n        \r\n        // Setup anti-bot config (disabled by default)\r\n        _antiBotConfig.initialize(\r\n            maxTxAmount > 0 ? maxTxAmount : totalSupply * 10 / 100,\r\n            maxWalletAmount > 0 ? maxWalletAmount : totalSupply * 20 / 100\r\n        );\r\n        \r\n        // Exclude owner from limits\r\n        isExcludedFromLimits[owner()] = true;\r\n    }\r\n    \r\n    function enableTrading() external onlyOwner {\r\n        require(!tradingEnabled, \"Trading already enabled\");\r\n        tradingEnabled = true;\r\n        launchTime = block.timestamp;\r\n        launchBlock = block.number;\r\n        emit TradingEnabled(launchTime);\r\n    }\r\n    \r\n    function setAntiBotEnabled(bool enabled) external onlyOwner {\r\n        _antiBotConfig.enabled = enabled;\r\n        emit AntiBotConfigUpdated(enabled, _antiBotConfig.maxTxAmount, _antiBotConfig.maxWalletAmount);\r\n    }\r\n    \r\n    function setMaxTxAmount(uint256 amount) external onlyOwner {\r\n        _antiBotConfig.maxTxAmount = amount;\r\n        emit AntiBotConfigUpdated(_antiBotConfig.enabled, amount, _antiBotConfig.maxWalletAmount);\r\n    }\r\n    \r\n    function setMaxWalletAmount(uint256 amount) external onlyOwner {\r\n        _antiBotConfig.maxWalletAmount = amount;\r\n        emit AntiBotConfigUpdated(_antiBotConfig.enabled, _antiBotConfig.maxTxAmount, amount);\r\n    }\r\n    \r\n    function excludeFromLimits(address account, bool excluded) external onlyOwner {\r\n        isExcludedFromLimits[account] = excluded;\r\n    }\r\n    \r\n    function updatePauseStatus(bool paused) external onlyOwner {\r\n        _securitySettings.setPaused(paused);\r\n        emit SecuritySettingsUpdated(paused);\r\n    }\r\n\r\n    function setContractStatus(\r\n        address contractAddr,\r\n        bool trusted,\r\n        bool blocked\r\n    ) external onlyOwner {\r\n        _securitySettings.setContractStatus(contractAddr, trusted, blocked);\r\n        emit ContractStatusChanged(contractAddr, trusted, blocked);\r\n    }\r\n\r\n    function _update(address from, address to, uint256 amount) internal override {\r\n        // Skip all checks for:\r\n        // 1. Owner operations\r\n        // 2. Excluded addresses\r\n        // 3. Initial distribution process\r\n        if (from == owner() || \r\n            to == owner() || \r\n            isExcludedFromLimits[from] || \r\n            isExcludedFromLimits[to] ||\r\n            !_initialDistributionComplete) {\r\n            super._update(from, to, amount);\r\n            return;\r\n        }\r\n\r\n        // Simple security check\r\n        require(!_securitySettings.paused, \"Transfers paused\");\r\n        \r\n        // Only check trading if not excluded\r\n        require(tradingEnabled, \"Trading not enabled\");\r\n\r\n        // Apply anti-bot measures only if enabled\r\n        if (_antiBotConfig.enabled) {\r\n            _antiBotConfig.applyAntiBotLimits(\r\n                address(this),\r\n                from,\r\n                to,\r\n                amount,\r\n                balanceOf(to),\r\n                launchTime,\r\n                launchBlock\r\n            );\r\n        }\r\n        \r\n        // Call the parent function to proceed with the transfer\r\n        super._update(from, to, amount);\r\n    }\r\n    \r\n    // Add helper function to exclude liquidity manager from all restrictions\r\n    function whitelistLiquidityManager(address manager) external onlyOwner {\r\n        isExcludedFromLimits[manager] = true;\r\n        _securitySettings.setContractStatus(manager, true, false);\r\n        emit ContractStatusChanged(manager, true, false);\r\n    }\r\n}"
    },
    "contracts/extensions/AntiBot.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title AntiBot\r\n * @dev Simplified anti-bot measures for token launches\r\n */\r\nlibrary AntiBot {\r\n    struct AntiBotConfig {\r\n        bool enabled;\r\n        uint256 maxTxAmount;\r\n        uint256 maxWalletAmount;\r\n        mapping(address => bool) blacklisted;\r\n    }\r\n    \r\n    /**\r\n     * @dev Initializes anti-bot configuration\r\n     * @param config Anti-bot config storage pointer\r\n     * @param _maxTxAmount Maximum transaction amount\r\n     * @param _maxWalletAmount Maximum wallet balance\r\n     */\r\n    function initialize(\r\n        AntiBotConfig storage config,\r\n        uint256 _maxTxAmount,\r\n        uint256 _maxWalletAmount\r\n    ) internal {\r\n        config.enabled = false; // Start disabled by default\r\n        config.maxTxAmount = _maxTxAmount;\r\n        config.maxWalletAmount = _maxWalletAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Applies simplified anti-bot checks\r\n     */\r\n    function applyAntiBotLimits(\r\n        AntiBotConfig storage config,\r\n        address tokenAddress,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 recipientBalance,\r\n        uint256 launchTime,\r\n        uint256 launchBlock\r\n    ) internal view {\r\n        // Only apply limits if enabled\r\n        if (!config.enabled) {\r\n            return;\r\n        }\r\n        \r\n        // Basic transaction amount limit\r\n        require(amount <= config.maxTxAmount, \"Transfer exceeds transaction limit\");\r\n        \r\n        // Basic wallet balance limit\r\n        require(recipientBalance + amount <= config.maxWalletAmount, \"Transfer exceeds wallet limit\");\r\n    }\r\n\r\n    function blacklistAddress(AntiBotConfig storage config, address account) internal {\r\n        config.blacklisted[account] = true;\r\n    }\r\n    \r\n    function removeFromBlacklist(AntiBotConfig storage config, address account) internal {\r\n        config.blacklisted[account] = false;\r\n    }\r\n}"
    },
    "contracts/extensions/LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IUniswapV3Factory {\r\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);\r\n}\r\n\r\ninterface INonfungiblePositionManager {\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function createAndInitializePoolIfNecessary(\r\n        address token0,\r\n        address token1,\r\n        uint24 fee,\r\n        uint160 sqrtPriceX96\r\n    ) external returns (address pool);\r\n    \r\n    function mint(MintParams calldata params) external payable returns (\r\n        uint256 tokenId,\r\n        uint128 liquidity,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n    \r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function factory() external view returns (address);\r\n    function WETH9() external view returns (address);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n    \r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n}\r\n\r\ncontract LiquidityManager is Ownable {\r\n    INonfungiblePositionManager public immutable positionManager;\r\n    IUniswapV3Factory public immutable factory;\r\n    IWETH public immutable weth;\r\n    \r\n    struct LockInfo {\r\n        uint256 tokenId;\r\n        uint256 unlockTime;\r\n    }\r\n    \r\n    mapping(uint256 => LockInfo) public liquidityLocks;\r\n    mapping(uint256 => address) public lockerOf;\r\n    \r\n    event LiquidityCreated(\r\n        address indexed token0, \r\n        address indexed token1, \r\n        uint256 tokenId, \r\n        uint256 liquidity\r\n    );\r\n    event LiquidityLocked(\r\n        uint256 indexed tokenId, \r\n        uint256 unlockTime\r\n    );\r\n    event LiquidityUnlocked(\r\n        uint256 indexed tokenId\r\n    );\r\n    \r\n    constructor(\r\n        address _positionManager, \r\n        address _initialOwner\r\n    ) Ownable(_initialOwner) {\r\n        positionManager = INonfungiblePositionManager(_positionManager);\r\n        factory = IUniswapV3Factory(positionManager.factory());\r\n        weth = IWETH(positionManager.WETH9());\r\n    }\r\n    \r\n    function createLiquidityPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 lockDuration\r\n    ) external payable returns (uint256 tokenId) {\r\n        address token0;\r\n        address token1;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        \r\n        // Handle ETH conversion if needed\r\n        if (msg.value > 0) {\r\n            require(tokenA == address(weth) || tokenB == address(weth), \"ETH only for WETH pairs\");\r\n            weth.deposit{value: msg.value}();\r\n            \r\n            // Adjust amounts if we received more ETH than needed\r\n            if (tokenA == address(weth) && msg.value > amountA) {\r\n                amountA = msg.value;\r\n            }\r\n            if (tokenB == address(weth) && msg.value > amountB) {\r\n                amountB = msg.value;\r\n            }\r\n        }\r\n        \r\n        // Determine token order\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        \r\n        // Set amounts based on token order\r\n        if (token0 == tokenA) {\r\n            amount0Desired = amountA;\r\n            amount1Desired = amountB;\r\n        } else {\r\n            amount0Desired = amountB;\r\n            amount1Desired = amountA;\r\n        }\r\n        \r\n        // Transfer tokens\r\n        if (token0 != address(weth)) {\r\n            TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0Desired);\r\n        } else if (msg.value < amount0Desired) {\r\n            // Need to transfer additional WETH if ETH sent wasn't enough\r\n            TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0Desired - msg.value);\r\n        }\r\n        \r\n        if (token1 != address(weth)) {\r\n            TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1Desired);\r\n        } else if (msg.value < amount1Desired) {\r\n            // Need to transfer additional WETH if ETH sent wasn't enough\r\n            TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1Desired - msg.value);\r\n        }\r\n        \r\n        // Approve position manager to spend tokens\r\n        TransferHelper.safeApprove(token0, address(positionManager), amount0Desired);\r\n        TransferHelper.safeApprove(token1, address(positionManager), amount1Desired);\r\n        \r\n        // Check if pool exists, initialize if necessary\r\n        address pool = IUniswapV3Factory(positionManager.factory()).getPool(token0, token1, fee);\r\n        if (pool == address(0)) {\r\n            // Calculate initial sqrt price\r\n            // For simplicity, we're using a 1:1 price ratio if pool doesn't exist\r\n            // In production, you may want to use price oracles or other methods\r\n            uint160 sqrtPriceX96;\r\n            \r\n            // Simple 1:1 price calculation adjusted for decimals\r\n            uint8 token0Decimals = IERC20Metadata(token0).decimals();\r\n            uint8 token1Decimals = IERC20Metadata(token1).decimals();\r\n            \r\n            if (token0Decimals == token1Decimals) {\r\n                // 1:1 ratio (Q64.96 format)\r\n                sqrtPriceX96 = 79228162514264337593543950336; // 2^96\r\n            } else if (token0Decimals > token1Decimals) {\r\n                // Adjust for decimal difference\r\n                uint8 decimalDiff = token0Decimals - token1Decimals;\r\n                sqrtPriceX96 = uint160(79228162514264337593543950336 * 10**(decimalDiff / 2));\r\n            } else {\r\n                // Adjust for decimal difference\r\n                uint8 decimalDiff = token1Decimals - token0Decimals;\r\n                sqrtPriceX96 = uint160(79228162514264337593543950336 / 10**(decimalDiff / 2));\r\n            }\r\n            \r\n            // Create and initialize the pool\r\n            positionManager.createAndInitializePoolIfNecessary(\r\n                token0,\r\n                token1,\r\n                fee,\r\n                sqrtPriceX96\r\n            );\r\n        }\r\n        \r\n        // Prepare mint params\r\n        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({\r\n            token0: token0,\r\n            token1: token1,\r\n            fee: fee,\r\n            tickLower: tickLower,\r\n            tickUpper: tickUpper,\r\n            amount0Desired: amount0Desired,\r\n            amount1Desired: amount1Desired,\r\n            amount0Min: 0,\r\n            amount1Min: 0,\r\n            recipient: address(this),\r\n            deadline: block.timestamp + 300\r\n        });\r\n        \r\n        // Mint NFT representing liquidity position\r\n        (tokenId, , , ) = positionManager.mint(params);\r\n        \r\n        emit LiquidityCreated(token0, token1, tokenId, 1);\r\n        \r\n        // Lock liquidity if duration is specified\r\n        if (lockDuration > 0) {\r\n            liquidityLocks[tokenId] = LockInfo({\r\n                tokenId: tokenId,\r\n                unlockTime: block.timestamp + lockDuration\r\n            });\r\n            lockerOf[tokenId] = msg.sender;\r\n            \r\n            emit LiquidityLocked(tokenId, block.timestamp + lockDuration);\r\n        } else {\r\n            // Transfer NFT back to sender\r\n            positionManager.transferFrom(address(this), msg.sender, tokenId);\r\n        }\r\n        \r\n        return tokenId;\r\n    }\r\n    \r\n    function unlockLiquidity(uint256 tokenId) external {\r\n        LockInfo storage lock = liquidityLocks[tokenId];\r\n        require(lock.tokenId == tokenId, \"No locked liquidity\");\r\n        require(block.timestamp >= lock.unlockTime, \"Liquidity still locked\");\r\n        require(lockerOf[tokenId] == msg.sender, \"Not the original locker\");\r\n        \r\n        // Clear the lock\r\n        delete liquidityLocks[tokenId];\r\n        delete lockerOf[tokenId];\r\n        \r\n        // Transfer NFT back to the original locker\r\n        positionManager.transferFrom(address(this), msg.sender, tokenId);\r\n        \r\n        emit LiquidityUnlocked(tokenId);\r\n    }\r\n    \r\n    // Fallback function to receive ETH\r\n    receive() external payable {}\r\n}"
    },
    "contracts/interfaces/IToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IToken {\r\n    function enableTrading() external;\r\n    function setAntiBotEnabled(bool enabled) external;\r\n    function setMaxTxAmount(uint256 amount) external;\r\n    function setMaxWalletAmount(uint256 amount) external;\r\n    function excludeFromLimits(address account, bool excluded) external;\r\n}"
    },
    "contracts/utils/SecurityUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @title SecurityUtils\r\n * @dev Simplified security utility functions for token contracts\r\n */\r\nlibrary SecurityUtils {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Struct to store contract security settings\r\n     */\r\n    struct SecuritySettings {\r\n        bool pausable;\r\n        bool paused;\r\n        bool blockContractsByDefault;\r\n        mapping(address => bool) blockedContracts;\r\n        mapping(address => bool) trustedContracts;\r\n    }\r\n    \r\n    /**\r\n     * @dev Initializes security settings with minimal defaults\r\n     * @param settings Security settings storage pointer\r\n     */\r\n    function initialize(SecuritySettings storage settings) internal {\r\n        settings.pausable = true;\r\n        settings.paused = false; // Start unpaused by default\r\n        settings.blockContractsByDefault = false;\r\n    }\r\n    \r\n    /**\r\n     * @dev Simplified security check that only blocks explicitly blacklisted contracts\r\n     * @param settings Security settings storage pointer\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     * @return bool Whether the transfer passes security checks\r\n     */\r\n    function isSecureTransfer(\r\n        SecuritySettings storage settings,\r\n        address from,\r\n        address to\r\n    ) internal view returns (bool) {\r\n        // Only block if explicitly paused\r\n        if (settings.pausable && settings.paused) {\r\n            return false;\r\n        }\r\n        \r\n        // Only block explicitly blacklisted contracts\r\n        if (isContract(from) && settings.blockedContracts[from]) {\r\n            return false;\r\n        }\r\n        \r\n        // Allow all other transfers\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Checks if an address is a contract\r\n     * @param addr Address to check\r\n     * @return bool Whether the address is a contract\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        return addr.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Validates an address is not zero address\r\n     * @param addr Address to validate\r\n     * @return bool Whether the address is valid\r\n     */\r\n    function isValidAddress(address addr) internal pure returns (bool) {\r\n        return addr != address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Sets a contract as trusted or blocked\r\n     * @param settings Security settings storage pointer\r\n     * @param contractAddr Contract address\r\n     * @param trusted Whether the contract should be trusted\r\n     * @param blocked Whether the contract should be blocked\r\n     */\r\n    function setContractStatus(\r\n        SecuritySettings storage settings,\r\n        address contractAddr,\r\n        bool trusted,\r\n        bool blocked\r\n    ) internal {\r\n        require(isContract(contractAddr), \"Address is not a contract\");\r\n        settings.trustedContracts[contractAddr] = trusted;\r\n        settings.blockedContracts[contractAddr] = blocked;\r\n    }\r\n    \r\n    /**\r\n     * @dev Toggles the paused state\r\n     * @param settings Security settings storage pointer\r\n     * @param paused Whether the contract should be paused\r\n     */\r\n    function setPaused(SecuritySettings storage settings, bool paused) internal {\r\n        require(settings.pausable, \"Contract is not pausable\");\r\n        settings.paused = paused;\r\n    }\r\n\r\n    function setBlockContractsByDefault(\r\n        SecuritySettings storage settings,\r\n        bool blocked\r\n    ) internal {\r\n        settings.blockContractsByDefault = blocked;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}